#!/usr/bin/python

#
# Copyright 2018 Armin Briegel, Scripting OS X
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A tool that helps manage and manipulate configuration profiles."""

import os
import subprocess
import shutil
import plistlib

import argparse

profiletool_version = '0.1'
args = []


def logger(log, v=0):
    if args.verbosity >= v:
        print log


def cmdexec(command):
    """Execute a command."""
    # if 'command' is a string, split the string into components
    if isinstance(command, str):
        command = command.split()

    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = proc.communicate()

    logger("cmdexec: %s, result: %s, error: %s" % (command, stdout, stderr), 3)

    # strip trailing whitespace, which would mess with string comparisons
    return {"return_code": proc.returncode, "stderr": stderr.rstrip(), "stdout": stdout.rstrip()}



def get_pref(pref_key, default=None):
    pref_domain = "com.github.autopkg"
    r = cmdexec(["defaults", "read", pref_domain, pref_key])
    if r["return_code"] == 0:
        return r["stdout"]

    if pref_key in os.environ:
        return os.environ[pref_key]

    return default



def test_pref(profile):
    if len(args.extra_args) > 0:
        keys = args.extra_args

    for x in keys:
        print "%s: %s" % (x, get_pref(x))


if __name__ == "__main__":
    actions = {
        'unsign': unsign_profile,
        'sign': sign_profile,
        'check-signature': check_profile_signature,
        'split': split_profile,
        'merge': merge_profiles,
        'reset-uuids': reset_profile_uuids,
        'reset-identifiers': reset_profile_identifiers,
        'print': print_profile,
        'pref': test_pref,
        }
    # step 0: parse input from cli

    # for convenience link to argparse tutorial:
    # https://docs.python.org/2/howto/argparse.html#id1
    parser = argparse.ArgumentParser(description='A tool that helps manage and manipulate configuration profiles.',
                                     epilog="""actions can be one of the following:
    unsign              removes a profiles signature
    sign                signs the profile
    check-signature     verifies the signature of a profile
    split               creates one new profile per payload of the original
    merge               combines the payload of multiple profiles into a single new profile
    reset-uuids         resets all PayloadUUID keys with new values
    reset-identifiers   resets all PayloadIdentifier keys with new values
    print               prints an overview of a profile's contents

    """, formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('--version', help='prints the version', action='version', version=profiletool_version)

    parser.add_argument('action', choices=sorted(actions.keys()), help='action to be applied to the recipe')

    parser.add_argument("-v", "--verbosity", action="count", default=0, help="controls amount of logging output (max -vvv)")

    parser.add_argument('profiles', help="configuration profile file", nargs='+')
    parser.add_argument('extra_args', nargs=argparse.REMAINDER, help="extra arguments will be passed through to 'edit' and 'status' commands")

    # finally, actually parse the arguments
    args = parser.parse_args()
    logger(args, 3)
    # args.func(args)



    # apply action to all items in profiles
    l = len(profiles)
    for p in profiles:
        actions[args.action](p)
